{-
 * @brief Estimate the amount of Jetton that can be minted based on the amount of TON provided.
 * 
 * @param amount_in The amount of TON provided for minting.
 * @return A tuple containing:
 *   - amount_out: The estimated amount of Jetton that will be minted.
 *   - true_amount_in: The actual amount of TON that will be added to the reserves.
 *   - ton_has_to_pay: The total amount of TON that has to be paid considering the fee rate.
-}
(int, int, int) simulate::estimate_mint_jetton_amount(
    int amount_in ;; The amount of TON provided for minting.
) inline_ref {
    int k = const::v_ton * master::total_supply; ;; this k come from original state
    int amount_in_after_fees = (amount_in * (const::precision - const::fee_rate) / const::precision); ;; Subtract mint fees
    int true_amount_in = min(amount_in_after_fees, const::ton_the_moon - master::ton_reserves); ;; Master can only mint up to const::ton_the_moon
    int ton_has_to_pay = true_amount_in * const::precision / (const::precision - const::fee_rate);

    ;; Calculate amount_out base on (x + delta_x ) * (y - delta_y) = k
    int x = master::ton_reserves + const::v_ton;
    int amount_out = master::jetton_reserves - (k / (x + true_amount_in));

    return (amount_out, true_amount_in, ton_has_to_pay);
}

{-
 * @brief Estimate the amount of TON obtained from burning Jetton tokens.
 * 
 * @param jetton_in The amount of Jetton tokens provided for burning.
 * @return A tuple containing:
 *   - amount_out: The estimated amount of TON obtained after fees.
 *   - delta_ton: The initial amount of TON before fees.
 *   - jetton_in: The amount of Jetton tokens provided for burning.
 *   - fee: The fee deducted from the initial amount of TON.
-}
(int, int, int) simulate::estimate_burn_jetton_amount(int jetton_in) inline_ref {
    
    int k = const::v_ton * master::total_supply; ;; this k come from original state
    int delta_ton = (master::ton_reserves + const::v_ton) - k / (master::jetton_reserves + jetton_in); ;; Calculate the ton amount out before fees
    int fee = delta_ton * const::fee_rate / const::precision; ;; Calculate the fee
    int amount_out = delta_ton - fee; ;; Calculate the amount out after fees

    return (amount_out, delta_ton, fee);
}

() mint_jetton(
    int bounce_flag,
    int query_id,
    int remaining_ton,
    int jetton_amount,
    slice recipient,
    slice response_address,
    int forward_ton_amount,
    cell forward_payload
) impure inline_ref {

    ;; Mint jetton to recipient
    cell msg_body = begin_cell()
    .store_op(op::internal_transfer)
    .store_query_id(query_id)
    .store_coins(jetton_amount)
    .store_slice(recipient)
    .store_slice(response_address)
    .store_coins(forward_ton_amount)
    .store_ref(forward_payload)
    .end_cell();

    ;; Calculate recipient's wallet address
    cell state_init = calculate_jetton_wallet_state_init(recipient, my_address(), master::jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);

    deploy(bounce_flag, to_wallet_address, remaining_ton, msg_body, state_init, SEND_MODE_REGULAR);
}

() transfer_ton(
    int query_id,
    int bounce_flag,
    slice recipient,
    int value,
    cell msg_body,
    int mode
) impure inline_ref {
    if msg_body.cell_null?() {
        msg_body = begin_cell()
        .store_op(op::excesses)
        .store_query_id(query_id)
        .end_cell();
    }

    var msg = begin_cell()
        .store_msg_flags_and_address_none(bounce_flag)
        .store_slice(recipient)
        .store_coins(value)
        .store_only_body_ref(msg_body);
    
    send_raw_message(msg.end_cell(), mode);
}

(cell) pack_add_ton_liquidity(
    int ton_amount,
    int pool_type,
    slice asset_0,
    slice asset_1,
    int min_lp_amount,
    int target_balance_0,
    int target_balance_1,
    int query_id
) impure inline_ref {
    cell msg_body = begin_cell()
        .store_op(op::deposit_ton_liquidity)
        .store_query_id(query_id)
        .store_coins(ton_amount)
        .store_uint(pool_type, 1)
        .store_slice(asset_0)
        .store_slice(asset_1)
        .store_ref(
            begin_cell()
                .store_coins(min_lp_amount)
                .store_coins(target_balance_0)
                .store_coins(target_balance_1)
            .end_cell()
        )
        .store_maybe_ref(null())
        .store_maybe_ref(null())
    .end_cell();

    return msg_body;
}

(cell) pack_add_jetton_liquidity(
    int pool_type,
    slice asset_0,
    slice asset_1,
    int min_lp_amount,
    int target_balance_0,
    int target_balance_1
) impure inline_ref {
    cell msg_body = begin_cell()
        .store_uint(op::deposit_jetton_liquidity, 32)
        .store_uint(pool_type, 1)
        .store_slice(asset_0)
        .store_slice(asset_1)
        .store_coins(min_lp_amount)
        .store_coins(target_balance_0)
        .store_coins(target_balance_1)
        .store_maybe_ref(null())
        .store_maybe_ref(null())
        .end_cell();
    return msg_body;
}