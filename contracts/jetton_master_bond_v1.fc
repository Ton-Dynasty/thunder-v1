#include "imports/stdlib.fc";
#include "common/errors.fc";
#include "common/workchain.fc";
#include "jetton_master/constants.fc";
#include "jetton_master/opcodes.fc";
#include "jetton_master/storages.fc";
#include "jetton_master/errors.fc";
#include "jetton_master/utils.fc";

() handle::mint(
    int query_id,
    slice ctx::sender, 
    int ctx::value, 
    int ctx::fwd_fee,
    int ton_amount,
    int mint_token_out,
    slice destination,
    slice response_address,
    cell custom_payload,
    int forward_ton_amount,
    cell forward_payload
) {
    ;; Check that user send enough TON to mint tokens and pay for gas fees
    ;; (int total_fees, int gas_consumptoin) = calculate_fees(ctx::fwd_fee); TODO: implement this gas calculation after whole code are ready @ipromise2324
    int total_fees = 50000000;
    int gas_consumptoin = 20000000;
    throw_unless(error::not_enough_ton, ctx::value > ton_amount + total_fees);
    
    ;; Calculate token_out based on ton_amount
    int token_out = simulate::estimate_mint_jetton_amount(ton_amount);
    throw_unless(error::not_meet_min_amount, token_out >= mint_token_out); ;; TODO: we should send back ton if token_out < mint_token_out

    ;; Mint tokens to user
    mint_jetton(
        BOUNCEABLE,
        query_id,
        token_out,
        ctx::sender,
        response_address,
        forward_ton_amount,
        forward_payload
    );
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    master::load_data();

    if (op == op::mint) {
        ;; load data in mint msg
        int ton_amount = ctx::body~load_coins();
        int mint_token_out = ctx::body~load_coins();
        slice destination = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        cell custom_payload = ctx::body~load_maybe_ref();
        int forward_ton_amount = ctx::body~load_coins();
        cell forward_payload = ctx::body~load_ref();

        return handle::mint(
            query_id, 
            ctx::sender, 
            ctx::value, 
            ctx::fwd_fee, 
            ton_amount,
            mint_token_out,
            destination,
            response_address,
            custom_payload,
            forward_ton_amount,
            forward_payload
        );
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}
