#include "imports/stdlib.fc";
#include "common/errors.fc";
#include "common/utils.fc";
#include "common/workchain.fc";
#include "jetton_master/constants.fc";
#include "jetton_master/opcodes.fc";
#include "jetton_master/storages.fc";
#include "jetton_master/errors.fc";
#include "jetton_master/utils.fc";
#include "jetton_master/gas.fc";

() handle::ton_the_moon(int query_id) impure inline {
    master::on_moon = 1;
    ;; Calculate the tunder fi fee 
    int send_ton_liquidity = master::ton_reserves * (const::precision - const::commission) / const::precision;
    int fee_for_admin = master::ton_reserves - send_ton_liquidity - ONE_TON; ;; ONE_TON is for building pool and farm.
    int price_for_now = const:price_precision * (master::ton_reserves + const::v_ton) / master::jetton_reserves;
    int send_jetton_liquidity = const:price_precision * send_ton_liquidity / price_for_now;
    int extra_jetton = master::jetton_reserves - send_jetton_liquidity;
    ;; TODO: We should use this extra_jetton to do something, but for now we substract it in total supply
    master::total_supply -= extra_jetton;

    ;; TODO: This ONE_TON / 20 need to be recalculated again
    cell add_liquidity_payload = begin_cell().store_uint(op::create_pool ,32).store_coins(send_ton_liquidity).store_slice(my_address()).end_cell();
    send_ton_liquidity += ONE_TON; ;; ONE_TON is for building pool and farm.
    int ton_to_dex_router = send_ton_liquidity + ONE_TON / 20  + fee_for_admin; ;; fee_for_admin will be transfer in excess msg. 
    ;; Send mint jetton to Router
    mint_jetton(
        BOUNCEABLE,
        query_id,
        ton_to_dex_router, 
        send_jetton_liquidity,
        master::dex_router,
        master::admin_address,
        send_ton_liquidity, 
        add_liquidity_payload
    );

    master::ton_reserves = 0;
    master::jetton_reserves = 0;
    master::fee = 0;

    return ();
}

() internal::mint_token(
    int query_id,
    slice ctx::sender, 
    int ctx::value, 
    int ctx::fwd_fee,
    int ton_amount,
    int min_token_out,
    slice destination,
    slice response_address,
    cell custom_payload,
    int forward_ton_amount,
    cell forward_payload
) impure inline_ref {
    ;; Check that user send enough TON to mint tokens and pay for gas fees
    (int total_fees, int gas_consumptoin) = cal_buy_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > ton_amount + total_fees + forward_ton_amount);
    
    ;; Calculate token_out based on ton_amount
    (int token_out, int true_amount_in, int ton_has_to_pay) = simulate::estimate_mint_jetton_amount(ton_amount);
    throw_unless(error::not_meet_min_amount, token_out >= min_token_out); ;; TODO: we should send back ton if token_out < min_token_out

    ;; Calculate remaining ton and update storage
    int ton_back_to_user = ctx::value - gas_consumptoin - ton_has_to_pay - forward_ton_amount;

    master::ton_reserves += true_amount_in;
    master::fee += ton_has_to_pay - true_amount_in;
    master::jetton_reserves -= token_out;

    if(master::ton_reserves == const::ton_the_moon) {
        handle::ton_the_moon(query_id);
    }

    ;; Mint tokens to user
    mint_jetton(
        BOUNCEABLE,
        query_id,
        ton_back_to_user,
        token_out,
        destination,
        response_address,
        forward_ton_amount,
        forward_payload
    );

    master::save_data();
    return ();
}

() internal::burn_token(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    int burn_amount,
    slice from_address,
    slice response_address
) impure inline_ref {

    ;; Calculate the gas fee
    (int total_fees, int gas_consumptoin) = cal_sell_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);

    int send_ton = ctx::value - gas_consumptoin;

    ;; Calculate sender's wallet address
    cell state_init = calculate_jetton_wallet_state_init(from_address, my_address(), master::jetton_wallet_code);
    slice true_sender = calculate_jetton_wallet_address(state_init);
    throw_unless(error::not_valid_wallet, equal_slices_bits(true_sender, ctx::sender));

    ;; Calculate amount out based on burn jetton_amount
    int amount_out = simulate::estimate_burn_jetton_amount(burn_amount);

    slice receiver = from_address;
    if (~ is_address_none(response_address)) {
        receiver = response_address;
    }

    transfer_ton(query_id, NON_BOUNCEABLE, receiver, amount_out + send_ton, SEND_MODE_REGULAR);

    master::save_data();
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    master::load_data();

    if (op == op::mint) {
        ;; load data in mint msg
        int ton_amount = ctx::body~load_coins();
        int min_token_out = ctx::body~load_coins();
        slice destination = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        cell custom_payload = ctx::body~load_maybe_ref();
        int forward_ton_amount = ctx::body~load_coins();
        cell forward_payload = ctx::body~load_ref();
        ctx::body.end_parse();

        ;; Throw error if token already listed. TODO: we should send back ton
        throw_unless(error::token_already_listed, master::on_moon == 0);

        ;; Throw error if token amount is equal to 0. TODO: we should send back ton
        throw_unless(error::invalid_amount, ton_amount > 0);

        internal::mint_token(
            query_id, 
            ctx::sender, 
            ctx::value, 
            ctx::fwd_fee, 
            ton_amount,
            min_token_out,
            destination,
            response_address,
            custom_payload,
            forward_ton_amount,
            forward_payload
        );
        return ();
    }

    if (op == op::burn_notification) {
        throw_unless(error::token_already_listed, master::on_moon == 0); ;; TODO: we should send back ton
        int jetton_amount = ctx::body~load_coins();
        slice from_address = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        ctx::body.end_parse();
        internal::burn_token(query_id, ctx::sender, ctx::value, ctx::fwd_fee, jetton_amount, from_address, response_address);

        return ();
    }

    if (op == op::change_content_cell) {
        throw_unless(error::not_admin, equal_slices_bits(ctx::sender, master::admin_address));
        master::jetton_content = ctx::body~load_ref();
        ctx::body.end_parse();
        master::save_data();
        return ();
    }

    if (op == op::upgrade) {
        throw_unless(error::not_admin, equal_slices_bits(ctx::sender, master::admin_address));
        (cell new_data, cell new_code) = (ctx::body~load_ref(), ctx::body~load_ref());
        ctx::body.end_parse();
        set_data(new_data);
        set_code(new_code);
        return ();
    }

    if(op == op::top_up) {
        return ();
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

;; public getters

slice get_wallet_address(slice owner_address) method_id {
    master::load_data();
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), master::jetton_wallet_code));
}

(int, int, int, int, int, slice, slice) get_master_data() method_id {
    master::load_data();
    return (master::ton_reserves, master::jetton_reserves, master::fee, master::total_supply, master::on_moon, master::dex_router, master::admin_address);
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    master::load_data();
    int total_supply = master::total_supply;
    slice admin_address = master::admin_address;
    cell jetton_wallet_code = master::jetton_wallet_code;
    int mintable = TRUE;
    return (total_supply, mintable, admin_address, master::jetton_content, jetton_wallet_code);
}