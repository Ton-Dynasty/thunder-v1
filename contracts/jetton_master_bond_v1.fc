#include "imports/stdlib.fc";
#include "common/errors.fc";
#include "common/utils.fc";
#include "common/workchain.fc";
#include "jetton_master_bond/constants.fc";
#include "jetton_master_bond/opcodes.fc";
#include "jetton_master_bond/storages.fc";
#include "jetton_master_bond/errors.fc";
#include "jetton_master_bond/utils.fc";
#include "jetton_master_bond/gas.fc";

() internal::ton_the_moon(int query_id, int ctx:fwd_fee) impure inline {
    master::on_moon = TRUE;
    ;; Calculate jetton reserves send to dex router and thunder fi admin fee
    int send_ton_liquidity = master::ton_reserves * (const::precision - const::commission) / const::precision; ;; Only send 90% of ton_reserves to liquidity pool
    int fee_for_admin = master::ton_reserves - send_ton_liquidity - BUILD_POOL_GAS_FEE + master::fee; ;; build_pool_fee is for building pool and farm, thunder fi will pay for it.

    ;; Calculate jetton reserves send to dex router
    int price_for_now = const:price_precision * (master::ton_reserves + const::v_ton) / master::jetton_reserves;
    int send_jetton_liquidity = const:price_precision * send_ton_liquidity / price_for_now;
    int extra_jetton = master::jetton_reserves - send_jetton_liquidity;
    ;; TODO: We should use this extra_jetton to do something, but for now we substract it in total supply
    master::total_supply -= extra_jetton;

    cell add_liquidity_payload = begin_cell()
        .store_uint(op::add_liquidity ,32)
        .store_coins(send_ton_liquidity) ;; other asset amount
        .store_slice(address_none()) ;; other asset wallet
        .store_coins(0) ;; min_lp_amount
        .store_slice(my_address()) ;; lp_receiver
        .store_maybe_ref(null()) ;; fulfill payload
        .store_maybe_ref(null()) ;; reject payload
        .end_cell();
    send_ton_liquidity += BUILD_POOL_GAS_FEE; ;; build_pool_fee is for building pool and farm and is paid by thunder fi in line 16
    int ton_to_dex_router = send_ton_liquidity + fee_for_admin; ;; fee_for_admin will be transfer in excess msg. 

    ;; Send mint jetton to Router
    mint_jetton(
        BOUNCEABLE,
        query_id,
        ton_to_dex_router, 
        send_jetton_liquidity,
        master::dex_router,
        master::admin_address,
        send_ton_liquidity, 
        add_liquidity_payload
    );

    ;; Update storage
    master::ton_reserves = 0;
    master::jetton_reserves = 0;
    master::fee = 0;

    return ();
}

() handle::claim_admin_fee(
    int query_id
) impure inline_ref {
    int send_ton = master::fee; ;; Remaining BUILD_POOL_GAS_FEE for building pool and farm
    transfer_ton(query_id, NON_BOUNCEABLE, master::admin_address, send_ton, SEND_MODE_REGULAR);

    master::fee = 0;
    master::save_data();
}

() handle::mint_token(
    int query_id,
    slice ctx::sender, 
    int ctx::value, 
    int ctx::fwd_fee,
    int ton_amount,
    int min_token_out,
    slice destination,
    slice response_address,
    cell custom_payload,
    int forward_ton_amount,
    cell forward_payload
) impure inline_ref {
    ;; Check that user send enough TON to mint tokens and pay for gas fees
    (int total_fees, int gas_consumptoin) = cal_buy_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > ton_amount + total_fees + forward_ton_amount);
    
    ;; Calculate token_out based on ton_amount
    (int token_out, int true_amount_in, int ton_has_to_pay) = simulate::estimate_mint_jetton_amount(ton_amount);
    throw_unless(error::not_meet_min_amount, token_out >= min_token_out); 

    ;; Calculate remaining ton and update storage
    int ton_back_to_user = ctx::value - gas_consumptoin - ton_has_to_pay;
    master::ton_reserves += true_amount_in;
    master::fee += ton_has_to_pay - true_amount_in;
    master::jetton_reserves -= token_out;

    ;; If ton_reserves reach to the moon threshold, then send to dex router to deploy liquidity pool
    if(master::ton_reserves == const::ton_the_moon) {
        internal::ton_the_moon(query_id, ctx::fwd_fee);
    }

    ;; Mint tokens to user
    mint_jetton(
        BOUNCEABLE,
        query_id,
        ton_back_to_user,
        token_out,
        destination,
        response_address,
        forward_ton_amount,
        forward_payload
    );

    master::save_data();
    return ();
}

() handle::burn_token(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    int burn_amount,
    slice from_address,
    slice response_address
) impure inline_ref {

    ;; Calculate the gas fee
    (int total_fees, int gas_consumptoin) = cal_sell_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - gas_consumptoin;

    ;; Calculate sender's wallet address
    cell state_init = calculate_jetton_wallet_state_init(from_address, my_address(), master::jetton_wallet_code);
    slice true_sender = calculate_jetton_wallet_address(state_init);
    throw_unless(error::not_valid_wallet, equal_slices_bits(true_sender, ctx::sender));

    ;; Calculate amount out based on burn jetton_amount
    (int amount_out, int delta_ton, int jetton_out, int fee) = simulate::estimate_burn_jetton_amount(burn_amount);
    
    ;; Upload storage
    master::ton_reserves -= delta_ton;
    master::jetton_reserves += jetton_out;
    master::fee += fee;

    ;; If user didn't provide response address to receive ton, then send to from_address
    slice recipient = from_address;
    if (~ is_address_none(response_address)) {
        recipient = response_address;
    }

    ;; Transfer tons (from selling meme tokens) to user
    transfer_ton(query_id, NON_BOUNCEABLE, recipient, amount_out + send_ton, SEND_MODE_REGULAR);

    master::save_data();
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    master::load_data();

    if op == op::mint {
        ;; load data in mint msg
        int ton_amount = ctx::body~load_coins();
        int min_token_out = ctx::body~load_coins();
        slice destination = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        cell custom_payload = ctx::body~load_maybe_ref();
        int forward_ton_amount = ctx::body~load_coins();
        cell forward_payload = ctx::body~load_ref();
        ctx::body.end_parse();

        ;; Throw error if token already listed. it will send back ton to user by bounce
        throw_unless(error::token_already_listed, master::on_moon == FALSE);

        ;; Throw error if token amount is equal to 0. it will send back ton to user by bounce
        throw_unless(error::invalid_amount, ton_amount > 0);

        handle::mint_token(
            query_id, 
            ctx::sender, 
            ctx::value, 
            ctx::fwd_fee, 
            ton_amount,
            min_token_out,
            destination,
            response_address,
            custom_payload,
            forward_ton_amount,
            forward_payload
        );
        return ();
    }

    if op == op::burn_notification {
        ;; Throw error if token already listed. it will send back jetton to user by bounce
        throw_unless(error::token_already_listed, master::on_moon == FALSE);
        int jetton_amount = ctx::body~load_coins();
        slice from_address = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        ctx::body.end_parse();
        handle::burn_token(query_id, ctx::sender, ctx::value, ctx::fwd_fee, jetton_amount, from_address, response_address);

        return ();
    }

    if op == op::provide_wallet_address {
        ;; see provide_wallet_address TL-B layout in jetton.tlb
        slice owner_address = ctx::body~load_msg_addr();
        int include_address? = ctx::body~load_bool();
        ctx::body.end_parse();

        cell included_address = include_address?
        ? begin_cell().store_slice(owner_address).end_cell()
        : null();

        ;; build MessageRelaxed, see TL-B layout in stdlib.fc#L733
        var msg = begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE)
        .store_slice(ctx::sender)
        .store_coins(0)
        .store_prefix_only_body()
        .store_op(op::take_wallet_address)
        .store_query_id(query_id);

        if (is_same_workchain(owner_address)) {
            msg = msg.store_slice(calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), master::jetton_wallet_code)));
        } else {
            msg = msg.store_address_none();
        }

        cell msg_cell = msg.store_maybe_ref(included_address).end_cell();

        send_raw_message(msg_cell, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
        return ();
    }

    if op == op::change_content_cell {
        throw_unless(error::not_admin, equal_slices_bits(ctx::sender, master::admin_address));
        master::jetton_content = ctx::body~load_ref();
        ctx::body.end_parse();
        master::save_data();
        return ();
    }

    if op == op::upgrade {
        throw_unless(error::not_admin, equal_slices_bits(ctx::sender, master::admin_address));
        (cell new_data, cell new_code) = (ctx::body~load_ref(), ctx::body~load_ref());
        ctx::body.end_parse();
        set_data(new_data);
        set_code(new_code);
        return ();
    }

    if op == op::claim_admin_fee {
        throw_unless(error::not_admin, equal_slices_bits(ctx::sender, master::admin_address));
        handle::claim_admin_fee(query_id);
        return ();
    }

    if op == op::top_up {
        return ();
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

;; public getters

slice get_wallet_address(slice owner_address) method_id {
    master::load_data();
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), master::jetton_wallet_code));
}

(int, int, int, int, int, slice, slice) get_master_data() method_id {
    master::load_data();
    return (master::ton_reserves, master::jetton_reserves, master::fee, master::total_supply, master::on_moon, master::dex_router, master::admin_address);
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    master::load_data();
    int total_supply = master::total_supply;
    slice admin_address = master::admin_address;
    cell jetton_wallet_code = master::jetton_wallet_code;
    int mintable = TRUE;
    return (total_supply, mintable, admin_address, master::jetton_content, jetton_wallet_code);
}