#include "imports/stdlib.fc";
#include "common/errors.fc";
#include "common/workchain.fc";
#include "jetton_master/constants.fc";
#include "jetton_master/opcodes.fc";
#include "jetton_master/storages.fc";
#include "jetton_master/errors.fc";
#include "jetton_master/utils.fc";

() handle::mint(
    int query_id,
    slice ctx::sender, 
    int ctx::value, 
    int ctx::fwd_fee,
    int ton_amount,
    int mint_token_out,
    slice destination,
    slice response_address,
    cell custom_payload,
    int forward_ton_amount,
    cell forward_payload
) impure inline_ref {
    ;; Check that user send enough TON to mint tokens and pay for gas fees
    ;; (int total_fees, int gas_consumptoin) = calculate_fees(ctx::fwd_fee); TODO: implement this gas calculation after whole code are ready @ipromise2324
    int total_fees = 50000000;
    int gas_consumptoin = 20000000;
    throw_unless(error::not_enough_ton, ctx::value > ton_amount + total_fees);
    
    ;; Calculate token_out based on ton_amount
    (int token_out, int true_amount_in) = simulate::estimate_mint_jetton_amount(ton_amount);
    throw_unless(error::not_meet_min_amount, token_out >= mint_token_out); ;; TODO: we should send back ton if token_out < mint_token_out

    ;; Calculate remaining ton and update storage
    int remaining_ton = ctx::value - gas_consumptoin - ton_amount;
    master::ton_reserves += true_amount_in;
    master::jetton_reserves -= token_out;
    master::fee += true_amount_in * const::fee_rate / const::precision;


    if(master::ton_reserves + token_out == const::ton_the_moon) {
        master::on_moon = 1;
        int send_ton_liquidity = master::ton_reserves * (const::precision - const::commission) / const::precision;
        cell add_liquidity_payload = begin_cell().store_uint(op::create_pool ,32).store_coins(send_ton_liquidity).end_cell();
        ;; Send mint jetton to Router
        mint_jetton(
            BOUNCEABLE,
            query_id,
            ONE_TON / 5, ;; 0.2 TON (TODO: modify this value when calculate fee)
            master::jetton_reserves,
            master::dex_router,
            my_address(),
            ONE_TON / 20, ;; 0.05 TON (TODO: modify this value when calculate fee)
            add_liquidity_payload
        );
    }


    ;; Mint tokens to user
    mint_jetton(
        BOUNCEABLE,
        query_id,
        remaining_ton,
        token_out,
        destination,
        response_address,
        forward_ton_amount,
        forward_payload
    );

    master::save_data();

    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    master::load_data();

    if (op == op::mint) {
        ;; load data in mint msg
        int ton_amount = ctx::body~load_coins();
        int mint_token_out = ctx::body~load_coins();
        slice destination = ctx::body~load_msg_addr();
        slice response_address = ctx::body~load_msg_addr();
        cell custom_payload = ctx::body~load_maybe_ref();
        int forward_ton_amount = ctx::body~load_coins();
        cell forward_payload = ctx::body~load_ref();

        handle::mint(
            query_id, 
            ctx::sender, 
            ctx::value, 
            ctx::fwd_fee, 
            ton_amount,
            mint_token_out,
            destination,
            response_address,
            custom_payload,
            forward_ton_amount,
            forward_payload
        );
        return ();
    }

    if (op == op::burn_notification) {
        throw_unless(error::token_already_listed, master::on_moon == 0);

        int jetton_amount = ctx::body~load_coins();
        slice from_address = ctx::body~load_msg_addr();


        ;; Calculate sender's wallet address
        cell state_init = calculate_jetton_wallet_state_init(ctx::sender, my_address(), master::jetton_wallet_code);
        slice true_sender = calculate_jetton_wallet_address(state_init);
        throw_unless(error::not_valid_wallet, equal_slices_bits(true_sender, ctx::sender));

        ;; Calculate amount out based on burn jetton_amount

        slice response_address = ctx::body~load_msg_addr();
        ctx::body.end_parse();

        slice receiver = from_address;
        if (~ is_address_none(response_address)) {
            receiver = response_address;
        }

        var msg = begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE)
        .store_slice(receiver) ;; dest
        .store_coins(0)
        .store_prefix_only_body()
        .store_op(op::excesses)
        .store_query_id(query_id);
        send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);

        return ();
    }

    if(op == op::top_up) {
        ~strdump("Deploy jetton master contract");
        return ();
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

slice get_wallet_address(slice owner_address) method_id {
    master::load_data();
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), master::jetton_wallet_code));
}

(int, int) get_reserves() method_id {
    master::load_data();
    return (master::ton_reserves, master::jetton_reserves);
}