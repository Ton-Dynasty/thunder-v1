#include "imports/stdlib.fc";
#include "common/workchain.fc";
#include "common/opcodes.fc";
#include "common/utils.fc";
#include "pool/opcodes.fc";
#include "dex_router/storages.fc";
#include "dex_router/opcodes.fc";
#include "dex_router/utils.fc";
#include "dex_router/errors.fc";
#include "dex_router/gas.fc";

;; ===== Internal =====
(slice, cell, cell) internal::deposit_asset(
    slice provider,
    slice main_wallet,
    slice other_asset_wallet,
    int send_ton,
    int query_id, 
    int asset0_amount, 
    int asset1_amount, 
    int min_lp_amount, 
    slice lp_recipient, 
    cell fulfill_payload, 
    cell reject_payload
) impure inline {

    cell deposit_asset_payload = pack_deposit_asset_data(
        query_id, 
        provider,
        asset0_amount, 
        asset1_amount, 
        min_lp_amount, 
        lp_recipient, 
        fulfill_payload, 
        reject_payload
    );

    ;; Calculate recipient's wallet address
    cell state_init = calculate_pool_state_init(main_wallet, other_asset_wallet);
    slice pool_address = calculate_address(state_init);


    deploy(BOUNCEABLE, pool_address, send_ton, deposit_asset_payload, state_init, SEND_MODE_REGULAR);

    return (pool_address, deposit_asset_payload, state_init);
}

;; ===== Handle =====
() handle::add_liquidity(
    int query_id,
    slice main_asset_wallet,  
    int ctx::value,
    int ctx::fwd_fee,
    int jetton_amount,
    slice jetton_sender,
    slice other_asset_wallet,
    int other_asset_amount,
    int min_lp_amount,
    slice recipient,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    int ton_amount = 0;
    if(is_address_none(other_asset_wallet)) {
        ton_amount = other_asset_amount;
    }

    (int total_fees, int gas_consumptoin) = cal_deploy_pool_fee(ctx::fwd_fee);
    if(ctx::value < total_fees + ton_amount) {
        ;; When this happens, dex router will take gas_consumption / 2 from the jetton sender
        transfer_jetton(BOUNCEABLE, main_asset_wallet, jetton_sender, jetton_amount, ctx::value - gas_consumptoin / 2, query_id, FORWARD_FEE, reject_payload, SEND_MODE_REGULAR);
        return();
    }
    int send_ton = ctx::value - ton_amount - gas_consumptoin;
    
    if (is_address_none(recipient)) {
        recipient = jetton_sender;
    }

    (slice asset_0_wallet, slice asset_1_wallet, int asset_0_amount, int asset_1_amount) = cal_order(main_asset_wallet, other_asset_wallet, jetton_amount, other_asset_amount);

    (slice pool_address, cell deposit_asset_payload, cell state_init) = internal::deposit_asset(
        jetton_sender,
        asset_0_wallet,
        asset_1_wallet,
        send_ton,
        query_id, 
        asset_0_amount, 
        asset_1_amount, 
        min_lp_amount, 
        recipient,
        fulfill_payload,
        reject_payload
    );

    return ();
}

() handle::swap_jetton(
    int query_id,
    slice ctx::sender,  
    int ctx::value,
    int ctx::fwd_fee,
    int jetton_amount,
    slice jetton_sender,
    slice other_asset_wallet,
    int asset_in,
    int min_amount_out,
    int deadline,
    slice recipient,
    cell next,
    cell extra_payload,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    (int total_fees, int gas_consumptoin) = cal_swap_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - gas_consumptoin;

    cell swap_jetton_payload = pack_swap_internal(
        query_id,
        jetton_sender,
        asset_in,
        jetton_amount,
        min_amount_out,
        deadline,
        recipient,
        extra_payload,
        fulfill_payload,
        reject_payload
    );

    (slice asset_0_wallet, slice asset_1_wallet, _, _) = cal_order(ctx::sender, other_asset_wallet, jetton_amount, 0);
    slice pool_address = calculate_address(calculate_pool_state_init(asset_0_wallet, asset_1_wallet));
    send_bounceable_msg(pool_address, send_ton, swap_jetton_payload, SEND_MODE_REGULAR);
    return ();
}

() handle::swap_ton(
    int query_id,
    slice ctx::sender,  
    int ctx::value,
    int ctx::fwd_fee,
    slice other_asset_wallet,
    int ton_amount,
    int min_amount_out,
    int deadline,
    slice recipient,
    cell next,
    cell extra_payload,
    cell fulfill_payload,
    cell reject_payload
) impure inline {

    (int total_fees, int gas_consumptoin) = cal_swap_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - ton_amount - gas_consumptoin;

    cell swap_ton_payload = pack_swap_internal(
        query_id,
        ctx::sender,
        0, ;; ton asset id is 0
        ton_amount,
        min_amount_out,
        deadline,
        recipient,
        extra_payload,
        fulfill_payload,
        reject_payload
    );

    slice pool_address = calculate_address(calculate_pool_state_init(address_none(), other_asset_wallet));

    send_bounceable_msg(pool_address, send_ton, swap_ton_payload, SEND_MODE_REGULAR);
    return ();
}

() handle::payout_from_pool(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    slice sender,
    slice target_wallet_address,
    slice other_wallet_address,
    int amount_out,
    slice recipient,
    cell payload
) impure inline {
    (slice asset_0_wallet, slice asset_1_wallet, _, _) = cal_order(other_wallet_address, target_wallet_address, 0, 0);
    slice pool_address = calculate_address(calculate_pool_state_init(asset_0_wallet, asset_1_wallet));
    ;; check if ctx::sender is the pool address
    throw_unless(error::invalid_sender, equal_slices_bits(pool_address, ctx::sender));

    (int total_fees, int gas_consumptoin) = cal_packout_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value + amount_out > total_fees);

    if (is_address_none(target_wallet_address)){
        int send_ton = ctx::value - gas_consumptoin + amount_out;
        transfer_ton(
            BOUNCEABLE, 
            query_id,
            recipient, 
            send_ton,
            payload, 
            SEND_MODE_REGULAR
        );
        return ();
    }
    int forward_ton = cell_null?(payload) ? 0 : FORWARD_FEE;
    int send_ton = ctx::value - forward_ton - gas_consumptoin;
    transfer_jetton(
        BOUNCEABLE, 
        target_wallet_address, 
        recipient, 
        amount_out, 
        send_ton, 
        query_id, 
        forward_ton, 
        payload, 
        SEND_MODE_REGULAR
    );
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    dex_router::load_data();
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();
    if(op == op::transfer_notification) {

        int jetton_amount = ctx::body~load_coins();
        slice jetton_sender = ctx::body~load_msg_addr();
        slice forward_payload = ctx::body~load_ref().begin_parse();

        op = forward_payload~load_op(); ;; op MUST be the first 32 bits of the payload in this case

        if(op == op::add_liquidity) {
            int other_asset_amount = forward_payload~load_coins();
            slice other_asset_wallet = forward_payload~load_msg_addr();
            int min_lp_amount = forward_payload~load_coins();
            slice recipient = forward_payload~load_msg_addr();
            cell fulfill_payload = forward_payload~load_maybe_ref();
            cell reject_payload = forward_payload~load_maybe_ref();

            return handle::add_liquidity(
                query_id,
                ctx::sender,   ;; dex router wallet address
                ctx::value,
                ctx::fwd_fee,
                jetton_amount,
                jetton_sender,
                other_asset_wallet,
                other_asset_amount,
                min_lp_amount,
                recipient,
                fulfill_payload,
                reject_payload
            );
        }

        if(op == op::swap_jetton) {
            slice other_asset_wallet = forward_payload~load_msg_addr();
            int asset_in = forward_payload~load_uint(1);
            int min_amount_out = forward_payload~load_coins();
            int deadline = forward_payload~load_uint(64);
            slice recipient = forward_payload~load_msg_addr();
            cell next = forward_payload~load_maybe_ref();
            cell extra_payload = forward_payload~load_maybe_ref();
            cell fulfill_payload = forward_payload~load_maybe_ref();
            cell reject_payload = forward_payload~load_maybe_ref();
            return handle::swap_jetton(
                query_id,
                ctx::sender,
                ctx::value,
                ctx::fwd_fee,
                jetton_amount,
                jetton_sender,
                other_asset_wallet,
                asset_in,
                min_amount_out,
                deadline,
                recipient,
                next,
                extra_payload,
                fulfill_payload,
                reject_payload
            );
        }
    }

    if(op == op::swap_ton) {
        slice other_asset_wallet = ctx::body~load_msg_addr();
        int ton_amount = ctx::body~load_coins();
        int min_amount_out = ctx::body~load_coins();
        int deadline = ctx::body~load_uint(64);
        slice recipient = ctx::body~load_msg_addr();
        cell next = ctx::body~load_maybe_ref();
        cell extra_payload = ctx::body~load_maybe_ref();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();
        return handle::swap_ton(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            other_asset_wallet,
            ton_amount,
            min_amount_out,
            deadline,
            recipient,
            next,
            extra_payload,
            fulfill_payload,
            reject_payload
        );
    }

    if(op == op::payout_from_pool) {
        slice sender = ctx::body~load_msg_addr();
        slice target_wallet_address = ctx::body~load_msg_addr();
        slice other_wallet_address = ctx::body~load_msg_addr();
        int amount_out = ctx::body~load_coins();
        slice recipient = ctx::body~load_msg_addr();
        cell payload = ctx::body~load_maybe_ref();
        return handle::payout_from_pool(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            sender,
            target_wallet_address,
            other_wallet_address,
            amount_out,
            recipient,
            payload
        );
    }

    if (op == op::top_up) {
        return ();
    }

    throw(0xffffff);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

;; ===== Getter =====
(slice) get_pool_address(slice asset_0, slice asset_1) method_id {
    dex_router::load_data();
    (slice asset_0_wallet, slice asset_1_wallet, _, _) = cal_order(asset_0, asset_1, 0, 0);
    ;; Calculate recipient's wallet address
    cell state_init = calculate_pool_state_init(asset_0_wallet, asset_1_wallet);
    slice pool_address = calculate_address(state_init);
    return pool_address;
}