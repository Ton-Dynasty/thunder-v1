#include "imports/stdlib.fc";
#include "common/workchain.fc";
#include "common/opcodes.fc";
#include "common/utils.fc";
#include "dex_router/storages.fc";
#include "dex_router/opcodes.fc";
#include "dex_router/utils.fc";
#include "dex_router/errors.fc";
#include "dex_router/gas.fc";


(slice, cell, cell) internal::deposit_asset(
    slice jetton_master_address,
    int query_id, 
    int asset0_amount, 
    int asset1_amount, 
    int min_lp_amount, 
    slice lp_receiver, 
    cell fulfill_payload, 
    cell reject_payload
) impure inline {
    cell deposit_asset_payload = pack_deposit_asset_data(
        query_id, 
        asset0_amount, 
        asset1_amount, 
        min_lp_amount, 
        lp_receiver, 
        fulfill_payload, 
        reject_payload
    );

    ;; Calculate receiver's wallet address
    cell state_init = calculate_pool_state_init(jetton_master_address);
    slice pool_address = calculate_address(state_init);

    return (pool_address, deposit_asset_payload, state_init);
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    dex_router::load_data();
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();
    if(op == op::transfer_notification) {

        int jetton_amount = ctx::body~load_coins();
        slice jetton_sender = ctx::body~load_msg_addr();
        slice forward_payload = ctx::body~load_ref().begin_parse();

        op = forward_payload~load_op(); ;; op MUST be the first 32 bits of the payload in this case

        if(op == op::create_pool) {
            int ton_amount = forward_payload~load_coins();
            slice master_address = forward_payload~load_msg_addr();

            (int total_fees, int gas_consumptoin) = cal_deploy_pool_fee(ctx::fwd_fee, 1);
            throw_unless(error::not_enough_ton, ctx::value > total_fees);
            int send_ton = ctx::value - gas_consumptoin;

            (slice pool_address, cell deposit_asset_payload, cell state_init) = internal::deposit_asset(
                master_address,
                query_id, 
                ton_amount, 
                jetton_amount, 
                0, 
                dex_router::owner_address, ;; lp receiver but this is first time add liqudity so there will be no LP token
                null(), ;; fulfill_payload
                null() ;; reject_payload
            );

            deploy(BOUNCEABLE, pool_address, send_ton, deposit_asset_payload, state_init, SEND_MODE_REGULAR);
            return ();
        }

        if(op == op::add_liquidity) {
            int ton_amount = forward_payload~load_coins();
            int min_lp_amount = forward_payload~load_coins();
            slice master_address = forward_payload~load_msg_addr();
            slice recipient = forward_payload~load_msg_addr();
            cell fulfill_payload = forward_payload~load_maybe_ref();
            cell reject_payload = forward_payload~load_maybe_ref();

            (int total_fees, int gas_consumptoin) = cal_deploy_pool_fee(ctx::fwd_fee, 0);
            throw_unless(error::not_enough_ton, ctx::value > total_fees + ton_amount);
            int send_ton = ctx::value - ton_amount - gas_consumptoin;
            

            if (is_address_none(recipient)) {
                recipient = jetton_sender;
            }

            (slice pool_address, cell deposit_asset_payload, cell state_init) = internal::deposit_asset(
                master_address,
                query_id, 
                ton_amount, 
                jetton_amount, 
                min_lp_amount, 
                recipient,
                fulfill_payload,
                reject_payload
            );

            send_bounceable_msg(pool_address, send_ton, deposit_asset_payload, SEND_MODE_REGULAR);

            return ();
        }

        if(op == op::swap_jetton) {
            return ();
        }
    }

    if(op == op::swap_ton) {
        return ();
    }

    if (op == op::top_up) {
        return ();
    }

    throw(0xffffff);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

(slice) get_pool_address(slice jetton_master_address) method_id {
    dex_router::load_data();
    ;; Calculate receiver's wallet address
    cell state_init = calculate_pool_state_init(jetton_master_address);
    slice pool_address = calculate_address(state_init);
    return pool_address;
}