#include "imports/stdlib.fc";
#include "common/workchain.fc";
#include "common/opcodes.fc";

global slice dex_router::owner_address;
global cell dex_router::pool_code;
const op::create_pool = "create_pool"c; ;; 2e3034ef
const op::top_up = 0xd372158c;
const op::deposit = "deposit"c; ;;95db9d39

() dex_router::load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    dex_router::owner_address = ds~load_msg_addr();
    dex_router::pool_code = ds~load_ref();

}

() dex_router::save_data() impure inline_ref {
    ;; set data
    set_data(
        begin_cell()
            .store_slice(dex_router::owner_address)
            .store_ref(dex_router::pool_code)
        .end_cell()
    );
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    dex_router::load_data();
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();
    if(op == op::transfer_notification) {

        int jetton_amount = ctx::body~load_coins();
        slice jetton_sender = ctx::body~load_msg_addr();
        slice forward_payload = ctx::body~load_ref().begin_parse();

        op = forward_payload~load_op(); ;; op MUST be the first 32 bits of the payload in this case

        if(op == op::create_pool) {
            int ton_amount = forward_payload~load_coins();
            slice master_address = forward_payload~load_msg_addr();
            return ();
        }
    }

    if (op == op::top_up) {
        return ();
    }

    throw(0xffffff);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

