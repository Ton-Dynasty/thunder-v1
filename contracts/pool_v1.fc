#include "imports/stdlib.fc";
#include "pool/storages.fc";
#include "common/opcodes.fc";
#include "common/workchain.fc";
#include "common/utils.fc";
#include "pool/constants.fc";
#include "pool/opcodes.fc";
#include "pool/errors.fc";
#include "pool/logs.fc";
#include "pool/gas.fc";
#include "imports/math.fc";
#include "pool/utils.fc";

;; ===== Internal =====



;; ===== Handle =====

() handle::deposit(
    int query_id,
    slice ctx::sender,  
    int ctx::value,
    int ctx::fwd_fee,
    slice provider,
    int asset0_amount,
    int asset1_amount,
    int min_lp_amount,
    slice lp_recipient,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    ;; Only dex router can send deposit message
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool::dex_router));

    ;; Make sure that sending ton is enough to complete the whole transaction
    (int total_fees, int gas_consumption) = cal_deposit_asset_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - gas_consumption;

    (lp_recipient, int lp_amount) = simulate::deposit(asset0_amount, asset1_amount, lp_recipient);
    if(min_lp_amount > lp_amount) {
        cell msg_body = pack_payout_from_pool(query_id, provider, provider, 0, asset0_amount, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

        cell msg_body2 = pack_payout_from_pool(query_id, provider, provider, 1, asset1_amount, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body2, SEND_MODE_REGULAR);
        return ();
    }

    mint_lp(query_id, lp_recipient, lp_amount, send_ton, fulfill_payload);

    if (is_address_none(lp_recipient)) {
        ;; create pool
        emit::create_pool(
            pool::admin_address,
            pool::asset0_wallet_address,
            pool::asset1_wallet_address,
            pool::reserve0,
            pool::reserve1,
            pool::lp_total_supply
        );
    } else {
        ;; deposit to existing pool
        emit::deposit(
            provider,
            lp_recipient,
            asset0_amount,
            asset1_amount,
            lp_amount,
            pool::reserve0,
            pool::reserve1,
            pool::lp_total_supply
        );
    }

    pool::save_data();
    return ();
}

() handle::swap_internal(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    slice sender,
    int asset_in,
    int amount_in,
    int min_amount_out,
    int deadline,
    slice recipient,
    cell extra_payload,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    ;; Make sure that only dex router can send swap message
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool::dex_router));

    (int total_fees, int gas_consumption) = cal_swap_internal(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - gas_consumption;
    if ((now() > deadline)) {
        cell msg_body = pack_payout_from_pool(query_id, sender, sender, asset_in, amount_in, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);
        return ();
    }

    if (is_address_none(recipient)) {
        recipient = sender;
    }

    (int amount_out, int trade_fee, int admin_fee) = simulate::get_amount_out(asset_in, amount_in);

    if(amount_out < min_amount_out) {
        cell msg_body = pack_payout_from_pool(query_id, sender, sender, asset_in, amount_in, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);
        return ();
    }

    int asset_out = 0;
    if (asset_in == 0) {
        pool::admin_fee0 += admin_fee;
        pool::reserve0 += (amount_in - admin_fee);
        pool::reserve1 -= amount_out;
        asset_out = 1;
    } else {
        pool::admin_fee1 += admin_fee;
        pool::reserve1 += (amount_in - admin_fee);
        pool::reserve0 -= amount_out;
        asset_out = 0;
    }

    cell msg_body = pack_payout_from_pool(query_id, sender, recipient, asset_out, amount_out, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);

    emit::swap(
        sender,
        recipient,
        asset_in,
        amount_in,
        amount_out,
        pool::reserve0,
        pool::reserve1,
        pool::lp_total_supply
    );

    pool::save_data();
    return ();
}

() handle::withdraw(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    slice jetton_sender,
    int lp_amount,
    int asset0_min_amount,
    int asset1_min_amount,
    slice recipient,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    if(is_address_none(recipient)) {
        recipient = jetton_sender;
    }

    slice pool_jetton_wallet = calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(my_address(),my_address(),pool::lp_jetton_wallet_code));
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool_jetton_wallet));

    (int total_fees, int gas_consumption) = cal_withdraw_internal(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int burn_fee = cal_burn_lp_fee(ctx::fwd_fee);
    int send_ton = ctx::value - gas_consumption - burn_fee;
    (int asset0_amount, int asset1_amount) = simulate::withdraw(lp_amount);

    ;; If the amount of asset0 or asset1 is less than the min amount, send lp back to the sender
    if((asset1_amount < asset1_min_amount) | (asset0_amount < asset0_min_amount)) {
        transfer_jetton(
            BOUNCEABLE, 
            ctx::sender, 
            jetton_sender, 
            lp_amount, 
            send_ton, 
            query_id, 
            FORWARD_FEE, 
            reject_payload, 
            SEND_MODE_REGULAR
        );
        return ();
    }

    cell msg_body = pack_payout_from_pool(query_id, jetton_sender, recipient, 0, asset0_amount, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

    msg_body = pack_payout_from_pool(query_id, jetton_sender, recipient, 1, asset1_amount, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

    ;; Send to pool jetton wallet to subtract balance
    cell data = pack_burn_data(query_id, lp_amount);
    send_bounceable_msg(pool_jetton_wallet, burn_fee, data, SEND_MODE_REGULAR);
    

    emit::withdraw(
        jetton_sender,
        recipient,
        lp_amount,
        asset0_amount,
        asset1_amount,
        pool::reserve0,
        pool::reserve1,
        pool::lp_total_supply
    );

    pool::save_data();
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    pool::load_data();

    ;; dispatch
    if (op == op::transfer_notification) {
        int jetton_amount = ctx::body~load_coins();
        slice jetton_sender = ctx::body~load_msg_addr();
        ctx::body~skip_bits(1);
        slice forward_payload = ctx::body~load_ref().begin_parse();

        op = forward_payload~load_op(); ;; op MUST be the first 32 bits of the payload in this case
        if (op == op::withdraw) {
            int asset0_min_amount = forward_payload~load_coins();
            int asset1_min_amount = forward_payload~load_coins();
            slice recipient = forward_payload~load_msg_addr();
            cell fulfill_payload = forward_payload~load_maybe_ref();
            cell reject_payload = forward_payload~load_maybe_ref();
            ctx::body.end_parse();
            return handle::withdraw(
                query_id,
                ctx::sender,
                ctx::value,
                ctx::fwd_fee,
                jetton_sender,
                jetton_amount,
                asset0_min_amount,
                asset1_min_amount,
                recipient,
                fulfill_payload,
                reject_payload
            );
        }
        return ();
    }

    if (op == op::deposit) {
        slice provider = ctx::body~load_msg_addr();
        int asset0_amount = ctx::body~load_coins();
        int asset1_amount = ctx::body~load_coins();
        int min_lp_amount = ctx::body~load_coins();
        slice lp_recipient = ctx::body~load_msg_addr();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();
        ctx::body.end_parse();
        
        handle::deposit(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            provider,
            asset0_amount,
            asset1_amount,
            min_lp_amount,
            lp_recipient,
            fulfill_payload,
            reject_payload
        );
        return ();
    }
    if (op == op::swap_internal){
        slice sender = ctx::body~load_msg_addr();
        int asset_in = ctx::body~load_uint(1);
        int amount_in = ctx::body~load_coins();
        int min_amount_out = ctx::body~load_coins();
        int deadline = ctx::body~load_uint(64);
        slice recipient = ctx::body~load_msg_addr();
        cell extra_payload = ctx::body~load_maybe_ref();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();
        ctx::body.end_parse();

        return handle::swap_internal(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            sender,
            asset_in,
            amount_in,
            min_amount_out,
            deadline,
            recipient,
            extra_payload,
            fulfill_payload,
            reject_payload
        );
    }

    if op == op::upgrade {
        throw_unless(error::invalid_sender, equal_slices_bits(ctx::sender, pool::admin_address));
        (cell new_data, cell new_code) = (ctx::body~load_ref(), ctx::body~load_ref());
        ctx::body.end_parse();
        set_data(new_data);
        if(~ null?(new_code)){
            set_code(new_code);
        }
        return ();
    }

    if op == op::provide_wallet_address {
        ;; see provide_wallet_address TL-B layout in jetton.tlb
        slice owner_address = ctx::body~load_msg_addr();
        int include_address? = ctx::body~load_bool();
        ctx::body.end_parse();

        cell included_address = include_address?
        ? begin_cell().store_slice(owner_address).end_cell()
        : null();

        ;; build MessageRelaxed, see TL-B layout in stdlib.fc#L733
        var msg = begin_cell()
        .store_msg_flags_and_address_none(NON_BOUNCEABLE)
        .store_slice(ctx::sender)
        .store_coins(0)
        .store_prefix_only_body()
        .store_op(op::take_wallet_address)
        .store_query_id(query_id);

        if (is_same_workchain(owner_address)) {
            msg = msg.store_slice(calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), pool::lp_jetton_wallet_code)));
        } else {
            msg = msg.store_address_none();
        }

        cell msg_cell = msg.store_maybe_ref(included_address).end_cell();

        send_raw_message(msg_cell, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);
        return ();
    }

    if op::claim_admin_fee {
        throw_unless(error::invalid_sender, equal_slices_bits(ctx::sender, pool::admin_address));

        (int total_fees, int gas_consumption) = cal_claim_admin_fee(ctx::fwd_fee);
        throw_unless(error::not_enough_ton, ctx::value > total_fees);
        
        int send_ton = (ctx::value - gas_consumption) / 2;
        cell msg_body = pack_payout_from_pool(query_id, ctx::sender, ctx::sender, 0, pool::admin_fee0, null());
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

        msg_body = pack_payout_from_pool(query_id, ctx::sender, ctx::sender, 1, pool::admin_fee1, null());
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

        pool::admin_fee0 = 0;
        pool::admin_fee1 = 0;
        pool::save_data();

        return ();
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

;; ===== Getters =====
slice get_wallet_address(slice owner_address) method_id {
    pool::load_data();
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), pool::lp_jetton_wallet_code));
}

(int, int, int, int, int) get_pool_data() method_id {
    pool::load_data();
    return (pool::reserve0, pool::reserve1, pool::lp_total_supply, pool::admin_fee0, pool::admin_fee1);
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    pool::load_data();
    (_, int hashpart) = parse_std_addr(my_address());

    cell content_lp = begin_cell()
        .store_uint(0x01, 8)
        .store_slice(URI_BASE)
        .store_slice(address_to_hex_string(hashpart))
        .store_slice(URI_END)
    .end_cell();

    return (pool::lp_total_supply, -1, pool::admin_address, content_lp, pool::lp_jetton_wallet_code);
}