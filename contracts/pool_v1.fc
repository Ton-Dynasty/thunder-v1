#include "imports/stdlib.fc";
#include "pool/storages.fc";
#include "common/opcodes.fc";
#include "common/workchain.fc";
#include "pool/constants.fc";
#include "pool/opcodes.fc";
#include "pool/errors.fc";
#include "pool/gas.fc";
#include "imports/math.fc";
#include "pool/utils.fc";

;; ===== Internal =====



;; ===== Handle =====

() handle::deposit(
    int query_id,
    slice ctx::sender,  
    int ctx::value,
    int ctx::fwd_fee,
    int asset0_amount,
    int asset1_amount,
    int min_lp_amount,
    slice lp_receiver,
    cell fulfill_payload,
    cell reject_payload
) {
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool::dex_router));
    int send_ton = ctx::value - gas::gas_consumption;
    (lp_receiver, int lp_amount) = simulate::deposit(asset0_amount, asset1_amount, lp_receiver);
    ;; TODO: refund and reject_payload
    throw_unless(error::insufficient_liquidity, lp_amount >= min_lp_amount);

    mint_lp(query_id, lp_receiver, lp_amount, send_ton, fulfill_payload);
    pool::save_data();
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    pool::load_data();

    ;; dispatch
    if (op == op::deposit) {
        int asset0_amount = ctx::body~load_coins();
        int asset1_amount = ctx::body~load_coins();
        int min_lp_amount = ctx::body~load_coins();
        slice lp_receiver = ctx::body~load_msg_addr();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();
        return handle::deposit(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            asset0_amount,
            asset1_amount,
            min_lp_amount,
            lp_receiver,
            fulfill_payload,
            reject_payload
        );
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}
