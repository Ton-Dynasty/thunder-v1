#include "imports/stdlib.fc";
#include "pool/storages.fc";
#include "common/opcodes.fc";
#include "common/workchain.fc";
#include "common/utils.fc";
#include "pool/constants.fc";
#include "pool/opcodes.fc";
#include "pool/errors.fc";
#include "pool/gas.fc";
#include "imports/math.fc";
#include "pool/utils.fc";

;; ===== Internal =====



;; ===== Handle =====

() handle::deposit(
    int query_id,
    slice ctx::sender,  
    int ctx::value,
    int ctx::fwd_fee,
    slice provider,
    int asset0_amount,
    int asset1_amount,
    int min_lp_amount,
    slice lp_recipient,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    ;; Only dex router can send deposit message
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool::dex_router));

    ;; Make sure that sending ton is enough to complete the whole transaction
    (int total_fees, int gas_consumption) = cal_deposit_asset_fee(ctx::fwd_fee);
    throw_unless(error::not_enough_ton, ctx::value > total_fees);
    int send_ton = ctx::value - gas_consumption;

    (lp_recipient, int lp_amount) = simulate::deposit(asset0_amount, asset1_amount, lp_recipient);
    if(min_lp_amount > lp_amount) {
        cell msg_body = pack_payout_from_pool(query_id, provider, provider, 0, asset0_amount, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body, SEND_MODE_REGULAR);

        cell msg_body2 = pack_payout_from_pool(query_id, provider, provider, 1, asset1_amount, reject_payload);
        send_bounceable_msg(pool::dex_router, send_ton / 2 , msg_body2, SEND_MODE_REGULAR);
        return ();
    }

    mint_lp(query_id, lp_recipient, lp_amount, send_ton, fulfill_payload);
    pool::save_data();
    return ();
}

() handle::swap_internal(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    slice sender,
    int asset_in,
    int amount_in,
    int min_amount_out,
    int deadline,
    slice recipient,
    cell extra_payload,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    throw_unless(error::invalid_sender, equal_slices(ctx::sender, pool::dex_router));
    int send_ton = ctx::value - gas::gas_consumption;
    if ((deadline == 0) | (now() > deadline)) {
        ;; TODO: deadline expired, return funds with reject_payload
        throw_unless(error::deadline_expired, false);
        return ();
    }
    
    if (asset_in > 1) {
        ;; TODO: asset not found, return funds with reject_payload
        throw_unless(error::asset_not_found, false);
        return ();
    }

    if (is_address_none(recipient)) {
        recipient = sender;
    }

    (int amount_out, int trade_fee) = simulate::get_amount_out(asset_in, amount_in);

    ;; TODO: insufficient_output_amount, return funds with reject_payload
    throw_unless(error::insufficient_out_amount, amount_out >= min_amount_out);

    int asset_out = 0;
    if (asset_in == 0) {
        pool::reserve0 += amount_in;
        pool::reserve1 -= amount_out;
        asset_out = 1;
    } else {
        pool::reserve1 += amount_in;
        pool::reserve0 -= amount_out;
        asset_out = 0;
    }

    cell msg_body = pack_payout_from_pool(query_id, sender, recipient, asset_out, amount_out, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);

    pool::save_data();
    return ();
}

() handle::withdraw(
    int query_id,
    slice ctx::sender,
    int ctx::value,
    int ctx::fwd_fee,
    int lp_amount,
    int asset0_min_amount,
    int asset1_min_amount,
    slice recipient,
    cell fulfill_payload,
    cell reject_payload
) impure inline {
    int send_ton = ctx::value - gas::gas_consumption;
    (int asset0_amount, int asset1_amount) = simulate::withdraw(lp_amount);

    ;; TODO: insufficient_output_amount, return funds with reject_payload
    throw_unless(error::insufficient_out_amount, asset0_amount >= asset0_min_amount);
    throw_unless(error::insufficient_out_amount, asset1_amount >= asset1_min_amount);

    cell msg_body = pack_payout_from_pool(query_id, ctx::sender, recipient, 0, asset0_amount, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);

    msg_body = pack_payout_from_pool(query_id, ctx::sender, recipient, 1, asset1_amount, fulfill_payload);
    send_bounceable_msg(pool::dex_router, send_ton , msg_body, SEND_MODE_REGULAR);

    ;; TODO: burn lp token

    pool::save_data();
    return ();
}

() route_internal(slice ctx::sender, int ctx::value, int ctx::fwd_fee, slice ctx::body) impure inline {
    ;; load op and query id
    (int op, int query_id) = ctx::body~load_op_and_query_id();

    ;; Load data from storage
    pool::load_data();

    ;; dispatch
    if (op == op::transfer_notification) {
        int jetton_amount = ctx::body~load_coins();
        slice jetton_sender = ctx::body~load_msg_addr();
        slice forward_payload = ctx::body~load_ref().begin_parse();

        op = forward_payload~load_op(); ;; op MUST be the first 32 bits of the payload in this case

        if (op == op::withdraw) {
            int asset0_min_amount = ctx::body~load_coins();
            int asset1_min_amount = ctx::body~load_coins();
            slice recipient = ctx::body~load_msg_addr();
            cell fulfill_payload = ctx::body~load_maybe_ref();
            cell reject_payload = ctx::body~load_maybe_ref();
            return handle::withdraw(
                query_id,
                ctx::sender,
                ctx::value,
                ctx::fwd_fee,
                jetton_amount,
                asset0_min_amount,
                asset1_min_amount,
                recipient,
                fulfill_payload,
                reject_payload
            );
        }
        return ();
    }

    if (op == op::deposit) {
        slice provider = ctx::body~load_msg_addr();
        int asset0_amount = ctx::body~load_coins();
        int asset1_amount = ctx::body~load_coins();
        int min_lp_amount = ctx::body~load_coins();
        slice lp_recipient = ctx::body~load_msg_addr();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();
        handle::deposit(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            provider,
            asset0_amount,
            asset1_amount,
            min_lp_amount,
            lp_recipient,
            fulfill_payload,
            reject_payload
        );
        return ();
    }
    if (op == op::swap_internal){
        slice sender = ctx::body~load_msg_addr();
        int asset_in = ctx::body~load_uint(1);
        int amount_in = ctx::body~load_coins();
        int min_amount_out = ctx::body~load_coins();
        int deadline = ctx::body~load_uint(64);
        slice recipient = ctx::body~load_msg_addr();
        cell extra_payload = ctx::body~load_maybe_ref();
        cell fulfill_payload = ctx::body~load_maybe_ref();
        cell reject_payload = ctx::body~load_maybe_ref();

        return handle::swap_internal(
            query_id,
            ctx::sender,
            ctx::value,
            ctx::fwd_fee,
            sender,
            asset_in,
            amount_in,
            min_amount_out,
            deadline,
            recipient,
            extra_payload,
            fulfill_payload,
            reject_payload
        );
    }

    if (op == op::top_up) {
        return ();
    }

    throw(error::invalid_op);
}

() main(int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags)) { ;; skip all bounced messages
        return ();
    }
    
    ;; get context
    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(MY_WORKCHAIN);

    ;; route function to handle internal message
    route_internal(ctx::sender, ctx::value, ctx::fwd_fee, ctx::body);
}

;; ===== Getters =====
slice get_wallet_address(slice owner_address) method_id {
    pool::load_data();
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, my_address(), pool::lp_jetton_wallet_code));
}

(int, int, int) get_pool_data() method_id {
    pool::load_data();
    return (pool::reserve0, pool::reserve1, pool::lp_total_supply);
}