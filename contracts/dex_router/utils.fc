cell pack_pool_data(slice dex_router_wallet_0, slice dex_router_wallet_1, cell lp_jetton_content) inline {

    slice main_wallet = address_none();
    slice other_wallet = address_none();

    if (equal_slices_bits(dex_router_wallet_0, address_none())) {
        main_wallet = dex_router_wallet_0;
        other_wallet = dex_router_wallet_1;
    } 
    elseif (equal_slices_bits(dex_router_wallet_1, address_none())) {
        main_wallet = dex_router_wallet_1;
        other_wallet = dex_router_wallet_0;
    } 
    else {
        if (dex_router_wallet_0.slice_hash() > dex_router_wallet_1.slice_hash()) {
            main_wallet = dex_router_wallet_0;
            other_wallet = dex_router_wallet_1;
        }
        else {
            main_wallet = dex_router_wallet_1;
            other_wallet = dex_router_wallet_0;
        }
    }

    cell init_data = begin_cell()
        .store_slice(my_address())
        .store_slice(main_wallet)
        .store_slice(other_wallet)
    .end_cell();

    return begin_cell()
            .store_slice(dex_router::owner_address)
            .store_coins(0) ;; reserve 0
            .store_coins(0) ;; reserve 1
            .store_coins(0) ;; total_supply
            .store_coins(1) ;; admin_fees
            .store_coins(1) ;; swap_fees
            .store_ref(init_data)
            .store_ref(dex_router::jetton_wallet_code)
            .store_ref(lp_jetton_content)
        .end_cell();
}

(cell) pack_deposit_asset_data(
    int query_id, 
    int asset0_amount, 
    int asset1_amount, 
    int min_lp_amount, 
    slice lp_recipient, 
    cell fulfill_payload, 
    cell reject_payload
) {
    ;; deposit asset payload
    cell msg_body = begin_cell()
        .store_op(op::deposit)
        .store_query_id(query_id)
        .store_coins(asset0_amount)
        .store_coins(asset1_amount)
        .store_coins(min_lp_amount)
        .store_slice(lp_recipient)
        .store_maybe_ref(null())
        .store_maybe_ref(null())
        .end_cell();
    return msg_body;
}

(cell) pack_swap_internal(
    int query_id, 
    slice sender,
    int asset_in,
    int amount_in, 
    int min_amount_out,
    int deadline, 
    slice recipient,
    cell extra_payload,
    cell fulfill_payload, 
    cell reject_payload
) {
    cell msg_body = begin_cell()
        .store_op(op::swap_internal)
        .store_query_id(query_id)
        .store_slice(sender)
        .store_uint(asset_in, 1)
        .store_coins(amount_in)
        .store_coins(min_amount_out)
        .store_uint(deadline, 64)
        .store_slice(recipient)
        .store_maybe_ref(extra_payload)
        .store_maybe_ref(fulfill_payload)
        .store_maybe_ref(reject_payload)
        .end_cell();
    return msg_body;
}

cell calculate_pool_state_init(slice dex_router_wallet_0, slice dex_router_wallet_1) inline {
    return begin_cell()
    .store_uint(0, 2) ;; 0b00 - No split_depth; No special
    .store_maybe_ref(dex_router::pool_code)
    .store_maybe_ref(
        pack_pool_data(
            dex_router_wallet_0,
            dex_router_wallet_1,
            begin_cell().end_cell() ;; TODO: This should replaced with real LP jetton content
        )
    )
    .store_uint(0, 1) ;; Empty libraries
    .end_cell();
}

slice calculate_address(cell state_init) inline {
    return begin_cell()
    .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
    .store_int(MY_WORKCHAIN, 8)
    .store_uint(cell_hash(state_init), 256)
    .end_cell()
    .begin_parse();
}

() transfer_jetton(
    int bounce_flag,
    slice jetton_wallet, 
    slice recipient, 
    int jetton_amount, 
    int ton_amount, 
    int query_id, 
    int forward_ton,
    cell payload, 
    int mode
) impure inline_ref {
    if(payload.cell_null?()) {
        forward_ton = 0;
    }

    ;; send jetton transfer to jetton wallet
    cell msg_body = begin_cell()
	.store_uint(op::transfer, 32)
	.store_uint(query_id, 64)
	.store_coins(jetton_amount)
	.store_slice(recipient)
	.store_slice(recipient)
	.store_uint(0, 1)
	.store_coins(forward_ton)
	.store_maybe_ref(payload)
	.end_cell();

    cell msg = begin_cell()
	.store_msg_flags_and_address_none(bounce_flag)
	.store_slice(jetton_wallet)
	.store_coins(ton_amount)
	.store_only_body_ref(msg_body)
	.end_cell();

    send_raw_message(msg, mode); 
}

() transfer_ton( ;; transfer TON with body
    int bounce_flag,
    int query_id,
    slice recipient,
    int value,
    cell body,
    int mode
) impure inline_ref {
    if (body.cell_null?()) {
        body = begin_cell()
        .store_op(op::excesses)
        .store_query_id(query_id)
        .end_cell();
    };
    var msg = begin_cell()
        .store_msg_flags_and_address_none(bounce_flag)
        .store_slice(recipient)
        .store_coins(value)
        .store_only_body_ref(body);
    
    send_raw_message(msg.end_cell(), mode);
}
